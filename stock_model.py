# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RrOIaOIw5R_8pE-QA5hHh5XmrZzXARAy
"""

import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import warnings
warnings.filterwarnings('ignore')

def display_live_market():
    """Display live Nifty 50 and Sensex values"""
    print("\n" + "="*80)
    print("üìä LIVE MARKET DATA")
    print("="*80)

    markets = {
        'NIFTY 50': '^NSEI',
        'SENSEX': '^BSESN',
        'BANK NIFTY': '^NSEBANK'
    }

    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"üïê Updated: {current_time}\n")

    for name, symbol in markets.items():
        try:
            ticker = yf.Ticker(symbol)
            hist = ticker.history(period='2d')

            if not hist.empty:
                current = hist['Close'].iloc[-1]
                if len(hist) > 1:
                    prev = hist['Close'].iloc[-2]
                    change = current - prev
                    change_pct = (change / prev) * 100
                else:
                    change = 0
                    change_pct = 0

                if change >= 0:
                    arrow = "üü¢‚ñ≤"
                    color = "\033[92m"
                else:
                    arrow = "üî¥‚ñº"
                    color = "\033[91m"

                reset = "\033[0m"
                print(f"{name:12} {color}‚Çπ{current:>10,.2f}  {arrow} {change:>+8,.2f} ({change_pct:>+6.2f}%){reset}")
        except:
            print(f"{name:12} ‚ùå Unable to fetch")

    print("="*80)

from typing import Optional, Any


class AdvancedStockPredictor:
    def __init__(self, symbol: str, period: str = '2y'):
        """
        Advanced ML Stock Predictor

        MODEL ARCHITECTURE:
        ==================
        1. Data Collection: yfinance (Yahoo Finance API)
        2. Feature Engineering: 60+ technical indicators
        3. ML Algorithms:
           - Random Forest (Ensemble of 200 decision trees)
           - Gradient Boosting (Sequential ensemble learning)
        4. Preprocessing: StandardScaler (normalize features)
        5. Validation: 80-20 Train-Test split
        6. Output: Binary classification (UP/DOWN prediction)

        Parameters:
        -----------
        symbol: Stock symbol (e.g., 'RELIANCE.NS', '^NSEI')
        period: Historical data period (1y, 2y, 5y)
        """
        self.symbol = symbol
        self.period = period
        # runtime values - annotate for static checkers
        self.data: Optional[pd.DataFrame] = None
        self.model: Optional[Any] = None
        self.model_name: Optional[str] = None
        self.scaler = StandardScaler()
        self.train_accuracy = 0
        self.test_accuracy = 0
        self.feature_importance = None

    def fetch_data(self):
        """Fetch stock data from yfinance"""
        print(f"\nüìä Fetching data for {self.symbol}...")
        ticker = yf.Ticker(self.symbol)
        self.data = ticker.history(period=self.period)

        if self.data.empty:
            print("‚ùå No data found. Check the symbol.")
            return False

        self.data.columns = self.data.columns.str.strip()
        print(f"‚úÖ Data fetched: {len(self.data)} days")
        return True

    def calculate_advanced_features(self):
        """
        Calculate 60+ technical indicators

        FEATURE CATEGORIES:
        ===================
        1. Trend Indicators: Moving Averages (SMA, EMA)
        2. Momentum Indicators: RSI, MACD, Stochastic, ROC
        3. Volatility Indicators: Bollinger Bands, ATR
        4. Volume Indicators: OBV, Volume Ratios, MFI
        5. Pattern Recognition: Price ratios, Crossovers
        """
        if self.data is None:
            print("‚ùå Error: No data available. Please fetch data first.")
            return None
            
        df = self.data.copy()

        # === 1. TREND INDICATORS ===
        # Moving Averages (captures trend direction)
        for window in [5, 10, 20, 50, 100, 200]:
            df[f'SMA_{window}'] = df['Close'].rolling(window=window).mean()
            df[f'EMA_{window}'] = df['Close'].ewm(span=window, adjust=False).mean()

        # Moving Average Crossovers (golden cross, death cross)
        df['SMA_Cross_20_50'] = (df['SMA_20'] > df['SMA_50']).astype(int)
        df['SMA_Cross_50_200'] = (df['SMA_50'] > df['SMA_200']).astype(int)

        # Price position relative to MAs
        df['Price_to_SMA20'] = (df['Close'] - df['SMA_20']) / df['SMA_20'] * 100
        df['Price_to_SMA50'] = (df['Close'] - df['SMA_50']) / df['SMA_50'] * 100

        # === 2. MOMENTUM INDICATORS ===
        # RSI - Relative Strength Index (overbought/oversold)
        for period in [7, 14, 21]:
            delta = df['Close'].diff().astype(float)
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            rs = gain / loss
            df[f'RSI_{period}'] = 100 - (100 / (1 + rs))

        # MACD - Moving Average Convergence Divergence (momentum)
        df['EMA_12'] = df['Close'].ewm(span=12, adjust=False).mean()
        df['EMA_26'] = df['Close'].ewm(span=26, adjust=False).mean()
        df['MACD'] = df['EMA_12'] - df['EMA_26']
        df['MACD_Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
        df['MACD_Hist'] = df['MACD'] - df['MACD_Signal']

        # Stochastic Oscillator (momentum)
        low_14 = df['Low'].rolling(window=14).min()
        high_14 = df['High'].rolling(window=14).max()
        df['Stochastic_K'] = 100 * (df['Close'] - low_14) / (high_14 - low_14)
        df['Stochastic_D'] = df['Stochastic_K'].rolling(window=3).mean()

        # Rate of Change
        df['ROC_10'] = ((df['Close'] - df['Close'].shift(10)) / df['Close'].shift(10)) * 100
        df['Momentum_10'] = df['Close'] - df['Close'].shift(10)

        # === 3. VOLATILITY INDICATORS ===
        # Bollinger Bands (price volatility)
        for window in [20, 50]:
            df[f'BB_Middle_{window}'] = df['Close'].rolling(window=window).mean()
            bb_std = df['Close'].rolling(window=window).std()
            df[f'BB_Upper_{window}'] = df[f'BB_Middle_{window}'] + (bb_std * 2)
            df[f'BB_Lower_{window}'] = df[f'BB_Middle_{window}'] - (bb_std * 2)
            df[f'BB_Width_{window}'] = (df[f'BB_Upper_{window}'] - df[f'BB_Lower_{window}']) / df[f'BB_Middle_{window}']
            df[f'BB_Position_{window}'] = (df['Close'] - df[f'BB_Lower_{window}']) / (df[f'BB_Upper_{window}'] - df[f'BB_Lower_{window}'])

        # ATR - Average True Range (volatility)
        high_low = df['High'] - df['Low']
        high_close = pd.Series(np.abs(df['High'] - df['Close'].shift()), index=df.index)
        low_close = pd.Series(np.abs(df['Low'] - df['Close'].shift()), index=df.index)
        ranges = pd.concat([high_low, high_close, low_close], axis=1)
        true_range = ranges.max(axis=1)
        df['ATR'] = true_range.rolling(14).mean()

        # Historical Volatility
        df['Returns'] = df['Close'].pct_change()
        df['Volatility_10'] = df['Returns'].rolling(window=10).std()
        df['Volatility_30'] = df['Returns'].rolling(window=30).std()

        # === 4. VOLUME INDICATORS ===
        # Volume analysis (confirms price movements)
        df['Volume_SMA_20'] = df['Volume'].rolling(window=20).mean()
        df['Volume_Ratio'] = df['Volume'] / df['Volume_SMA_20']
        df['Volume_Change'] = df['Volume'].pct_change()

        # OBV - On-Balance Volume (buying/selling pressure)
        obv_series = pd.Series(np.sign(df['Close'].diff()), index=df.index) * df['Volume']
        df['OBV'] = obv_series.fillna(0).cumsum()

        # MFI - Money Flow Index (volume-weighted RSI)
        typical_price = (df['High'] + df['Low'] + df['Close']) / 3
        money_flow = typical_price * df['Volume']
        positive_flow = money_flow.where(typical_price > typical_price.shift(1), 0).rolling(14).sum()
        negative_flow = money_flow.where(typical_price < typical_price.shift(1), 0).rolling(14).sum()
        mfi_ratio = positive_flow / negative_flow
        df['MFI'] = 100 - (100 / (1 + mfi_ratio))

        # === 5. PATTERN RECOGNITION ===
        # Price patterns
        df['High_Low_Ratio'] = df['High'] / df['Low']
        df['Close_Open_Ratio'] = df['Close'] / df['Open']

        # Target variable: 1 if price goes up next day, 0 otherwise
        df['Target'] = (df['Close'].shift(-1) > df['Close']).astype(int)

        self.data = df
        return df

    def prepare_ml_data(self):
        """Prepare data for machine learning"""
        assert self.data is not None, "No data available - call fetch_data() first"
        df = self.data.dropna()

        # Select features
        feature_cols = [col for col in df.columns if col not in
                       ['Target', 'Open', 'High', 'Low', 'Close', 'Volume',
                        'Dividends', 'Stock Splits', 'Returns']]

        X = df[feature_cols]
        y = df['Target']

        # Handle infinite and very large values
        X = X.replace([np.inf, -np.inf], np.nan)

        # Fill NaN with column mean
        X = X.fillna(X.mean())

        # Clip extreme values (beyond 5 standard deviations)
        for col in X.columns:
            mean = X[col].mean()
            std = X[col].std()
            if std > 0:
                lower_bound = mean - (5 * std)
                upper_bound = mean + (5 * std)
                X[col] = X[col].clip(lower_bound, upper_bound)

        # Time-series split (80% train, 20% test)
        split_idx = int(len(X) * 0.8)
        X_train, X_test = X[:split_idx], X[split_idx:]
        y_train, y_test = y[:split_idx], y[split_idx:]

        # Normalize features using StandardScaler
        X_train_scaled = self.scaler.fit_transform(X_train)
        X_test_scaled = self.scaler.transform(X_test)

        return X_train_scaled, X_test_scaled, y_train, y_test, feature_cols

    def train_model(self):
        """
        Train ML models using ensemble methods

        ALGORITHMS USED:
        ================
        1. Random Forest Classifier:
           - Ensemble of 200 decision trees
           - Max depth: 10 (prevents overfitting)
           - Votes: Majority voting from all trees
           - Good for: Handling non-linear relationships

        2. Gradient Boosting Classifier:
           - Sequential ensemble (learns from mistakes)
           - 200 weak learners (decision stumps)
           - Learning rate: 0.1
           - Good for: Capturing complex patterns

        Selection: Best model based on test accuracy
        """
        print("\nü§ñ Training Machine Learning Models...")

        X_train, X_test, y_train, y_test, feature_cols = self.prepare_ml_data()

        # Random Forest: Parallel ensemble of decision trees
        print("   Training Random Forest (200 trees)...")
        rf_model = RandomForestClassifier(
            n_estimators=200,      # Number of trees
            max_depth=10,          # Maximum tree depth
            min_samples_split=5,   # Min samples to split node
            min_samples_leaf=2,    # Min samples in leaf node
            random_state=42,
            n_jobs=-1              # Use all CPU cores
        )
        rf_model.fit(X_train, y_train)

        # Gradient Boosting: Sequential ensemble learning
        print("   Training Gradient Boosting (200 estimators)...")
        gb_model = GradientBoostingClassifier(
            n_estimators=200,      # Number of boosting stages
            max_depth=5,           # Depth of individual trees
            learning_rate=0.1,     # Step size shrinkage
            random_state=42
        )
        gb_model.fit(X_train, y_train)

        # Evaluate both models
        rf_train_acc = accuracy_score(y_train, rf_model.predict(X_train))
        rf_test_acc = accuracy_score(y_test, rf_model.predict(X_test))

        gb_train_acc = accuracy_score(y_train, gb_model.predict(X_train))
        gb_test_acc = accuracy_score(y_test, gb_model.predict(X_test))

        # Select best model
        if rf_test_acc >= gb_test_acc:
            self.model = rf_model
            self.train_accuracy = rf_train_acc
            self.test_accuracy = rf_test_acc
            self.model_name = "Random Forest"
        else:
            self.model = gb_model
            self.train_accuracy = gb_train_acc
            self.test_accuracy = gb_test_acc
            self.model_name = "Gradient Boosting"

        print(f"\n‚úÖ Best Model Selected: {self.model_name}")

        # Feature importance (which indicators matter most)
        feature_imp = pd.DataFrame({
            'feature': feature_cols,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)

        self.feature_importance = feature_imp

        # Detailed evaluation
        y_pred = self.model.predict(X_test)

        print(f"\nüìä Model Performance Metrics:")
        print(f"   Training Accuracy:   {self.train_accuracy*100:.2f}%")
        print(f"   Testing Accuracy:    {self.test_accuracy*100:.2f}%")
        print(f"   Generalization Gap:  {(self.train_accuracy - self.test_accuracy)*100:.2f}%")

        if self.train_accuracy - self.test_accuracy < 0.05:
            print("   Status: ‚úÖ Good generalization (low overfitting)")
        else:
            print("   Status: ‚ö†Ô∏è  Some overfitting detected")

        return X_test, y_test, y_pred

    def get_current_prediction(self):
        """Get ML prediction for current market"""
        assert self.data is not None, "No data available - call fetch_data() first"
        assert self.model is not None, "Model not trained - call train_model() first"
        latest_data = self.data.iloc[-1:].copy()

        feature_cols = [col for col in self.data.columns if col not in
                       ['Target', 'Open', 'High', 'Low', 'Close', 'Volume',
                        'Dividends', 'Stock Splits', 'Returns']]

        X_latest = latest_data[feature_cols]

        # Handle infinite and NaN values
        X_latest = X_latest.replace([np.inf, -np.inf], np.nan)
        X_latest = X_latest.fillna(0)

        X_latest_scaled = self.scaler.transform(X_latest)

        # mypy/pylance: model is Any (set after training) so calls below are valid at runtime
        prediction = self.model.predict(X_latest_scaled)[0]  # type: ignore[attr-defined]
        probability = self.model.predict_proba(X_latest_scaled)[0]  # type: ignore[attr-defined]

        return prediction, probability

    def analyze_technical_signals(self):
        """Analyze technical indicators"""
        assert self.data is not None, "No data available - call fetch_data() first"
        latest = self.data.iloc[-1]
        signals = {}

        # RSI
        if latest['RSI_14'] < 30:
            signals['RSI'] = {'status': 'OVERSOLD - BUY', 'value': latest['RSI_14'], 'strength': 'Strong'}
        elif latest['RSI_14'] > 70:
            signals['RSI'] = {'status': 'OVERBOUGHT - SELL', 'value': latest['RSI_14'], 'strength': 'Strong'}
        else:
            signals['RSI'] = {'status': 'NEUTRAL', 'value': latest['RSI_14'], 'strength': 'Weak'}

        # MACD
        if latest['MACD'] > latest['MACD_Signal']:
            signals['MACD'] = {'status': 'BULLISH', 'strength': 'Moderate'}
        else:
            signals['MACD'] = {'status': 'BEARISH', 'strength': 'Moderate'}

        # Moving Averages
        if latest['SMA_20'] > latest['SMA_50']:
            signals['MA_Trend'] = {'status': 'BULLISH', 'strength': 'Strong'}
        else:
            signals['MA_Trend'] = {'status': 'BEARISH', 'strength': 'Weak'}

        # Bollinger Bands
        if latest['BB_Position_20'] < 0.2:
            signals['Bollinger'] = {'status': 'NEAR LOWER BAND - BUY', 'strength': 'Strong'}
        elif latest['BB_Position_20'] > 0.8:
            signals['Bollinger'] = {'status': 'NEAR UPPER BAND - SELL', 'strength': 'Strong'}
        else:
            signals['Bollinger'] = {'status': 'MID RANGE', 'strength': 'Weak'}

        # Stochastic
        if latest['Stochastic_K'] < 20:
            signals['Stochastic'] = {'status': 'OVERSOLD - BUY', 'strength': 'Moderate'}
        elif latest['Stochastic_K'] > 80:
            signals['Stochastic'] = {'status': 'OVERBOUGHT - SELL', 'strength': 'Moderate'}
        else:
            signals['Stochastic'] = {'status': 'NEUTRAL', 'strength': 'Weak'}

        return signals

    def print_model_explanation(self):
        """Print detailed model explanation"""
        print("\n" + "="*80)
        print("ü§ñ MODEL ARCHITECTURE & FEATURES")
        print("="*80)

        print("\nüìö WHAT WE'RE USING:")
        print("-" * 80)
        print("\n1. DATA SOURCE:")
        print("   ‚Ä¢ yfinance (Yahoo Finance API) - Real-time & historical data")

        print("\n2. MACHINE LEARNING ALGORITHMS:")
        print(f"   ‚Ä¢ Selected Model: {self.model_name}")
        print("   ‚Ä¢ Random Forest: Ensemble of 200 decision trees")
        print("   ‚Ä¢ Gradient Boosting: Sequential learning from errors")
        print("   ‚Ä¢ Preprocessing: StandardScaler (feature normalization)")

        print("\n3. TECHNICAL INDICATORS (60+ features):")
        print("   üìà Trend Indicators:")
        print("      - SMA (5, 10, 20, 50, 100, 200 days)")
        print("      - EMA (5, 10, 20, 50, 100, 200 days)")
        print("      - Golden Cross/Death Cross signals")
        print("\n   üí™ Momentum Indicators:")
        print("      - RSI (7, 14, 21 periods) - Overbought/Oversold")
        print("      - MACD + Signal Line + Histogram")
        print("      - Stochastic Oscillator (K & D)")
        print("      - Rate of Change (ROC)")
        print("\n   üìä Volatility Indicators:")
        print("      - Bollinger Bands (20 & 50 periods)")
        print("      - ATR (Average True Range)")
        print("      - Historical Volatility")
        print("\n   üì¶ Volume Indicators:")
        print("      - Volume Ratios & Changes")
        print("      - OBV (On-Balance Volume)")
        print("      - MFI (Money Flow Index)")

        print("\n4. TRAINING METHODOLOGY:")
        print("   ‚Ä¢ Data Split: 80% Training / 20% Testing")
        print("   ‚Ä¢ Validation: Time-series split (no data leakage)")
        print("   ‚Ä¢ Target: Binary classification (UP/DOWN next day)")

        print("\n5. PREDICTION LOGIC:")
        print("   ‚Ä¢ ML Model Weight: 60%")
        print("   ‚Ä¢ Technical Analysis Weight: 40%")
        print("   ‚Ä¢ Combined score determines BUY/SELL/HOLD")

    def print_comprehensive_analysis(self):
        """Print complete analysis"""
        assert self.data is not None, "No data available - call fetch_data() first"
        latest = self.data.iloc[-1]

        # Show model explanation first
        self.print_model_explanation()

        print("\n" + "="*80)
        print(f"üìà STOCK ANALYSIS: {self.symbol}")
        print("="*80)
        # latest.name may be a Timestamp-like object; coerce to datetime safely
    # Use a safe string conversion for the index/date
        print(f"üìÖ Date: {str(latest.name)}")
        print(f"üí∞ Current Price: ‚Çπ{latest['Close']:.2f}")

        # ML Prediction
        print("\n" + "="*80)
        print("ü§ñ MACHINE LEARNING PREDICTION")
        print("="*80)

        prediction, probability = self.get_current_prediction()
        confidence = max(probability) * 100

        if prediction == 1:
            print(f"\nüü¢ ML PREDICTION: PRICE LIKELY TO GO UP")
            print(f"   Up Probability: {probability[1]*100:.2f}%")
            print(f"   Down Probability: {probability[0]*100:.2f}%")
        else:
            print(f"\nüî¥ ML PREDICTION: PRICE LIKELY TO GO DOWN")
            print(f"   Down Probability: {probability[0]*100:.2f}%")
            print(f"   Up Probability: {probability[1]*100:.2f}%")

        # Top Features
        print(f"\nüìä Top 10 Most Important Features:")
        if self.feature_importance is not None:
            for i, (_idx, row) in enumerate(self.feature_importance.head(10).iterrows(), start=1):
                print(f"   {i:2}. {row['feature']:30} ‚Üí {row['importance']*100:.2f}%")

        # Technical Analysis
        print("\n" + "="*80)
        print("üìä TECHNICAL INDICATORS")
        print("="*80)

        signals = self.analyze_technical_signals()

        buy_count = 0
        sell_count = 0

        for indicator, data in signals.items():
            print(f"\n{indicator}:")
            print(f"   Status: {data['status']}")
            print(f"   Strength: {data['strength']}")
            if 'value' in data:
                print(f"   Value: {data['value']:.2f}")

            if 'BUY' in data['status'] or 'BULLISH' in data['status'] or 'OVERSOLD' in data['status']:
                buy_count += 1
            elif 'SELL' in data['status'] or 'BEARISH' in data['status'] or 'OVERBOUGHT' in data['status']:
                sell_count += 1

        # Final Recommendation
        print("\n" + "="*80)
        print("üéØ FINAL RECOMMENDATION")
        print("="*80)

        technical_score = (buy_count / (buy_count + sell_count)) * 100 if (buy_count + sell_count) > 0 else 50
        ml_score = confidence if prediction == 1 else (100 - confidence)

        # Weighted: 60% ML + 40% Technical
        final_score = (ml_score * 0.6) + (technical_score * 0.4)

        print(f"\nüìä Score Breakdown:")
        print(f"   ML Score (60% weight):        {ml_score:.2f}%")
        print(f"   Technical Score (40% weight): {technical_score:.2f}%")
        print(f"   Combined Final Score:         {final_score:.2f}%")
        print(f"   Technical Signals:            {buy_count} BUY vs {sell_count} SELL")

        if final_score >= 65:
            recommendation = "üü¢ STRONG BUY"
            action = "Good time to BUY"
        elif final_score >= 50:
            recommendation = "üü° MODERATE BUY"
            action = "Consider buying with caution"
        elif final_score >= 35:
            recommendation = "üü† HOLD"
            action = "Wait for better signals"
        else:
            recommendation = "üî¥ AVOID/SELL"
            action = "Not recommended to buy"

        print(f"\n{recommendation}")
        print(f"üí° Action: {action}")

        print("\n" + "="*80)
        print("‚ö†Ô∏è  DISCLAIMER: For educational purposes only!")
        print("    Always do your own research before investing.")
        print("="*80)

    def run(self):
        """Run complete analysis"""
        if not self.fetch_data():
            return None

        print("üìä Calculating 60+ technical indicators...")
        self.calculate_advanced_features()

        self.train_model()
        self.print_comprehensive_analysis()


def main():
    """Main function"""
    # Display live market data first
    display_live_market()

    print("\nüöÄ Advanced ML Stock Prediction System")
    print("="*80)

    stocks = [
        '^NSEI',        # Nifty 50
        'RELIANCE.NS',  # Reliance
        'TCS.NS',       # TCS
        'INFY.NS',      # Infosys
        'HDFCBANK.NS',  # HDFC Bank
        'ITC.NS',       # ITC
    ]

    print("\nPopular stocks:")
    for i, stock in enumerate(stocks, 1):
        print(f"{i}. {stock}")

    print(f"{len(stocks) + 1}. Enter custom stock")

    choice = input(f"\nEnter choice (1-{len(stocks)+1}): ").strip()

    try:
        choice_num = int(choice)
        if 1 <= choice_num <= len(stocks):
            symbol = stocks[choice_num - 1]
        else:
            symbol = input("Enter stock symbol (e.g., RELIANCE.NS): ").strip().upper()
    except:
        symbol = choice.upper()
        if not symbol.endswith(('.NS', '.BO')) and not symbol.startswith('^'):
            symbol = symbol + '.NS'

    period = input("Enter period (1y/2y/5y) [default: 2y]: ").strip() or '2y'

    predictor = AdvancedStockPredictor(symbol, period)
    predictor.run()


if __name__ == "__main__":
    main()